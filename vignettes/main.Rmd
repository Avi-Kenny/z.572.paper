---
title: "572 Paper Reproduction"
output: rmarkdown::word_document
vignette: >
  %\VignetteIndexEntry{main}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Load packages
```{r}

install.packages(
  pkgs = 'plotly',
  lib = '/home/students/avikenny/Desktop/R_lib', # UW - Bayes
  repos=c(
    'http://cran.us.r-project.org', 
    INLA="https://inla.r-inla-download.org/R/stable"
  ),
  dependencies = TRUE,
  verbose = TRUE,
  keep_outputs=TRUE
)

library(z.572.paper)
library(sp)
library(rgeos)
library(spdep)
library(parallel)
library(rgdal)
library(simba)
library(ggplot2)
library(dplyr)
library(magrittr)
library(permute)
library(maps)
library(maptools)
library(mvtnorm)
library(rjags) # !!!!! On hutch load module: JAGS/4.2.0-foss-2016b
library(MASS)
library(pbapply)
library(ngspatial)
library(Matrix)
library(INLA)
# INLA:::inla.dynload.workaround()
# INLA:::inla.call.builtin()

```



# Set code blocks to run
```{r}

run_fig1 <- FALSE
run_fig2 <- FALSE
run_fig3 <- FALSE
run_ima <- FALSE

```



# Generate objects to be used throughout code
```{r}

adj_mtx_path <- generate_graph_path() %>% adj_from_graph()
adj_mtx_grid <- generate_graph_grid() %>% adj_from_graph()
adj_mtx_US <- adj_from_gis_us()

```



# Generate figure 1
```{r}
if (run_fig1) {
  
  rhos <- seq(from=0.1, to=0.9, by=0.1)
  rho_out <- c()
  
  for (adj_mtx in list(adj_mtx_path, adj_mtx_grid, adj_mtx_US)) {
    
    for (rho in rhos) {
      
      # Generate average neighbor-pair correlation for DAGAR
      mtx_dagar <- generate_mtx(model="DAGAR", adj_mtx=adj_mtx, rho=rho)
      cov_dagar <- solve(mtx_dagar$Q)
      
      cor <- 0
      count <- 0
      for (i in 2:length(mtx_dagar$neighbors)) {
        
        nbs <- mtx_dagar$neighbors[[i]]
        if (nbs[1]!=0) {
          for (nb in 1:length(nbs)) {
            j <- nbs[nb]
            cor <- cor + ( cov_dagar[i,j] / 
              (sqrt(cov_dagar[i,i]) * sqrt(cov_dagar[j,j])) )
            count <- count+1
          }
        }
        
      }
      anpc_dagar <- cor/count
      rho_out <- c(rho_out, anpc_dagar)
      
      # Generate average neighbor-pair correlation for CAR
      mtx_car <- generate_mtx(model="CAR", adj_mtx=adj_mtx, rho=rho)
      cov_car <- solve(mtx_car$Q)
      cor <- 0
      count <- 0
      for (i in 1:length(mtx_car$neighbors)) {
        
        nbs <- mtx_car$neighbors[[i]]
        if (nbs[1]!=0) {
          for (nb in 1:length(nbs)) {
            j <- nbs[nb]
            cor <- cor + ( cov_car[i,j] / 
              (sqrt(cov_car[i,i]) * sqrt(cov_car[j,j])) )
            count <- count+1
          }
        }
        
      }
      anpc_car <- cor/count
      rho_out <- c(rho_out, anpc_car)
    
    }
  
  }
  
  # Plot results
  ggplot(
    data = data.frame(
      x = rep(rep(rhos, each=2), 3),
      y = rho_out,
      grp = rep(c("DAGAR","CAR"), 27),
      type = rep(c(
        "(a) Path graph of length 100",
        "(b) 10 x 10 grid",
        "(c) 48 contiguous US states"
      ), each=18)
    ),
    aes(x=x, y=y, group=grp,
        color=as.factor(grp))) + 
    geom_segment(x=0, y=0, xend=1, yend=1, color="grey") +
    geom_line() + geom_point(size=3) +
    scale_color_manual(values=c("firebrick", "darkolivegreen4")) +
    xlim(0,1) +
    ylim(0,1) +
    facet_wrap(~type, ncol=3) +
    labs(
      title = paste0("Figure 1. Average neighbor pair correlations as a function",
                     " of rho for proper CAR and DAGAR model"),
      x = "rho",
      y = "Average neighbor correlation",
      color = "Model"
    ) +
    theme(legend.position = "bottom")
  
}
```



# Generate figure 2
```{r}
if (run_fig2) {
  
  rd_path <- function(p) {
    sqrt(
      (4*p^8 + 2*p^4) / ( (3+6*p^2+p^4)^2 + (18*p^2*(1+p^2)^2) + (2*p^4) )
    )
  }
  
  s <- function(p) {
    1 / ( 1 + (1-1)*p^2 ) +
    2 / ( 1 + (2-1)*p^2 ) +
    3 / ( 1 + (3-1)*p^2 ) +
    4 / ( 1 + (4-1)*p^2 )
  }
  
  rd_grid <- function(p) {
    sqrt(
      (
        p^4 * ( s(p)/5 - 2/(1+p^2) )^2 +
        2 * ( 1/3 - s(p)/30 - p^2/(1+p^2) )^2 +
        12 * ( 1/6 - s(p)/60 )^2
      ) /
      (
        ( 1 + p^2 + p^2*(s(p)/5) )^2 +
        4 * p^2 +
        20 * ( 1/6 - s(p)/60 )^2
      )
    )
  }
  
  # Generate data
  n <- 101
  rhos <- seq(from=0, to=1, length.out=n)
  
  # Plot results
  ggplot(
    data = data.frame(
      x = rep(rhos, 2),
      y = c( rd_path(rhos), rd_grid(rhos) ),
      grp = rep(c("(a) Path graph","(b) Grid graph"), each=n)
    ),
    aes(x=x, y=y, group=grp)
  ) +
    geom_line() + 
    geom_text(
      data = data.frame(
        x = rep(seq(from=0, to=1, by=0.25), 2),
        y = c(
          round(rd_path(c(0, 0.25, 0.5, 0.75, 1)),2),
          round(rd_grid(c(0, 0.25, 0.5, 0.75, 1)),2)
        ),
        grp = rep(c("(a) Path graph", "(b) Grid graph"), each=5)
      ),
      aes(x=x, y=y, label=y),
      size = 2
    ) +
    xlim(0,1) +
    # ylim(0,1) +
    facet_wrap(~grp, ncol=2) +
    labs(
      title = paste0("Figure 2. Asymptotic relative difference between the DAGAR",
                     "model and the order free DAGAR model"),
      x = "rho",
      y = "Relative difference"
    )
  
}
```



# Generate figure 3
```{r}
if (run_fig3) {
  
  set.seed(1)
  
  start_time <- Sys.time()
  
  sim <- new_sim()
  
  sim %<>% set_config(
    num_sim = 10, # !!!!!
    parallel = "outer",
    packages = c("z.572.paper", "sp", "rgeos", "spdep", "parallel", "rgdal",
                 "simba", "ggplot2", "dplyr", "magrittr", "permute", "maps", 
                 "maptools", "mvtnorm", "rjags", "MASS", "ngspatial")
  )
  
  sim %<>% add_constants(
    tau_w = 0.25,
    adj_mtx_path = generate_graph_path() %>% adj_from_graph(),
    adj_mtx_grid = generate_graph_grid() %>% adj_from_graph(),
    adj_mtx_US = adj_from_gis_us()
  )
  
  sim %<>% set_levels(
    type = c("path", "grid", "US"),
    rho = seq(from=0.1, to=0.9, by=0.1),
    model = c("iCAR", "CAR", "DAGAR", "DAGAR_OF", "SGLMM", "Scaled iCAR")
    # type = "path",
    # rho = 0.5
    # model = c("iCAR", "DAGAR")
  )
  
  sim %<>% add_creator(generate_dataset)
  
  sim %<>% add_script(
    "script_mainsim",
    function(L,C) {
      
      # Set variables depending on `type`
      switch(
        L$type,
        "path" = {
          k <- 100
          adj_mtx <- C$adj_mtx_path
        },
        "grid" = {
          k <- 100
          adj_mtx <- C$adj_mtx_grid
        },
        "US" = {
          k <- 48
          adj_mtx <- C$adj_mtx_US
        }
      )
      
      # Generate data
      data <- generate_dataset(
        type = L$type,
        tau_w = C$tau_w,
        phi = -1*log(L$rho)
        # type = "path",
        # tau_w = 0.25,
        # phi = -1*log(0.9)
      )
      
      # Create necessary matrices and objects to send to JAGS (depending on model)
      # Create JAGS code
      
      if (L$model %in% c("iCAR", "CAR", "Scaled iCAR")) {
        mtx <- generate_mtx(L$model, adj_mtx)
        D <- mtx$D
        n_i <- mtx$n_i
      }
      
      if (L$model == "iCAR") {
        
        # !!!!! What happened to the "0.999999*D" ?
        
        # JAGS model code
        jags_code <- quote("
          model {
            for (i in 1:k) {
              y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
            }
            
            w ~ dmnorm(mu0, Q)
            Q <- tau_w * (D-(0.999999*A))
            
            beta1 ~ dnorm(0, 0.0001)
            beta2 ~ dnorm(0, 0.0001)
            tau_w ~ dgamma(2, 1)
            tau_e ~ dgamma(2, 0.1)
          }
        ")
        
      }
      
      if (L$model == "Scaled iCAR") {
        
        sigma2ref <- exp(mean(log(diag(ginv(D - adj_mtx)))))
        
        # JAGS model code
        jags_code <- quote("
          model {
            for (i in 1:k) {
              y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
            }
            
            w ~ dmnorm(mu0, Q)
            Q <- tau_w * (D-(0.999999*A))
            
            beta1 ~ dnorm(0, 0.0001)
            beta2 ~ dnorm(0, 0.0001)
            tau_w ~ dgamma(2, sigma2ref)
            tau_e ~ dgamma(2, 0.1)
          }
        ")
        
      } else {
        sigma2ref <- NULL
      }
      
      if (L$model == "CAR") {
        
        # JAGS model code
        jags_code <- quote("
          model {
            for (i in 1:k) {
              y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
            }
            
            w ~ dmnorm(mu0, Q)
            Q <- tau_w * (D - (rho*A))
            
            beta1 ~ dnorm(0, 0.0001)
            beta2 ~ dnorm(0, 0.0001)
            tau_w ~ dgamma(2, 1)
            tau_e ~ dgamma(2, 0.1)
            rho ~ dunif(0, 1)
          }
        ")
        
      }
      
      if (L$model=="DAGAR") {
        
        mtx <- generate_mtx(L$model, adj_mtx)
        n_i <- mtx$n_i
  
        # JAGS model code
        jags_code <- quote("
          model {
            for (i in 1:k) {
              y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
            }
            
            w ~ dmnorm(mu0, Q)
            Q <- tau_w * (t(L) %*% FF %*% L)
            L <- I - B
            
            for (i in 1:k) {
              for (j in 1:k) {
                
                FF[i,j] <- ifelse(i==j, tau[i], 0)
                B[i,j] <- ifelse(
                  j<i && A[i,j]==1,
                  rho / (1+(n_i[i]-1)*(rho^2)),
                  0
                )
                
              }
            }
            
            tau <- (1+(n_i-1)*(rho^2)) / (1-rho^2)
            
            beta1 ~ dnorm(0, 0.0001)
            beta2 ~ dnorm(0, 0.0001)
            tau_w ~ dgamma(2, 1)
            tau_e ~ dgamma(2, 0.1)
            rho ~ dunif(0, 1)
          }
        ")
        
      } else if (L$model=="DAGAR_OF") {
        
        # This is an approximation and not the "true" DAGAR_OF
        
        mtx <- generate_mtx(L$model, adj_mtx)
        n_i <- mtx$n_i
  
        # JAGS model code
        jags_code <- quote("
          model {
            for (i in 1:k) {
              y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
            }
            
            w ~ dmnorm(mu0, Q)
            Q <- tau_w * (t(L) %*% FF %*% L)
            L <- I - B
            
            B <- 0.5 * (B1+B2)
            FF <- 0.5 * (FF1+FF2)
            
            for (i in 1:k) {
              for (j in 1:k) {
                
                FF1[i,j] <- ifelse(i==j, tau[i], 0)
                B1[i,j] <- ifelse(
                  j>i && A[i,j]==1,
                  rho / (1+(n_i[i]-1)*(rho^2)),
                  0
                )
                FF2[i,j] <- ifelse(i==j, tau[i], 0)
                B2[i,j] <- ifelse(
                  j<i && A[i,j]==1,
                  rho / (1+(n_i[i]-1)*(rho^2)),
                  0
                )
                
              }
            }
            
            tau <- (1+(n_i-1)*(rho^2)) / (1-rho^2)
            
            beta1 ~ dnorm(0, 0.0001)
            beta2 ~ dnorm(0, 0.0001)
            tau_w ~ dgamma(2, 1)
            tau_e ~ dgamma(2, 0.1)
            rho ~ dunif(0, 1)
          }
        ")
        
      } else {
        n_i <- NULL
      }
      
      if (L$model == "SGLMM") {
        
        sm <- sparse.sglmm(
          y ~ x1 + x2,
          data = data.frame(y=data$y, x1=data$x1, x2=data$x2),
          A = adj_mtx,
          method = "RSR",
          attractive = 100,
          minit = 4000,
          maxit = 8000
          # attractive = 48 # !!!!! test this value for "grid" and "US"
        )
        
        # !!!!! TO DO
        # y[i] ~ dnorm(x1[i]*beta1 + x2[i]*beta2 + w[i], tau_e)
        
        w_hat <- 999 # !!!!!
        
      } else {
  
        # Run JAGS model
        jm <- jags.model(
          file = textConnection(jags_code),
          data = list(
            k = k,
            x1 = data$x1,
            x2 = data$x2,
            y = data$y,
            D = D,
            I = diag(rep(1,k)),
            A = adj_mtx,
            n_i = n_i,
            sigma2ref = sigma2ref,
            mu0 = rep(0,k)
          ),
          n.chains = 1,
          n.adapt = 1000
        )
        output <- coda.samples(
          model = jm,
          variable.names = "w",
          n.iter = 1000,
          thin = 1
        )
        # summary(output)
        
        # Calculate MSE
        w_hat <- as.numeric(summary(output)$quantiles[,"50%"])
        
      }
      
      mse <- mean((data$w-w_hat)^2)
      
      return (list("mse" = mse))
      
    }
  )
  
  sim %<>% run("script_mainsim")
  
  saveRDS(sim, file=paste("sim",Sys.time()))
  # sim <- readRDS("../sim 2020-05-04 01_00_37")
  
  summ <- sim %>% summary() %>% arrange(model, type, rho)
  
  # Plot results
  # !!!!! Need to test this
  ggplot(
    data = summ,
    aes(x=rho, y=mean_mse, group=model,
        color=as.factor(model))) + 
    geom_line() + geom_point(size=1) +
    # scale_color_manual(values=c("firebrick", "darkolivegreen4")) +
    xlim(0,1) +
    ylim(0,4) +
    facet_wrap(~type, ncol=3) +
    labs(
      title = paste0("Figure 3. MSE as a function of the true rho for the ",
                     "exponential GP simulation data"),
      x = "rho",
      y = "MSE",
      color = "Model"
    ) +
    theme(legend.position = "right")
  
  print(round(difftime(Sys.time(), start_time),2))
  
}
```



# Infant mortality analysis
```{r}
if (run_ima) {
  
  # Sparse sGLMM: load/transform data
  data(infant)
  data(A)
  infant %<>% mutate(low_weight = low_weight/births)
  infant$id <- c(1:3071)
  
  # Sparse sGLMM: run model 
  # set.seed(12)
  # fit = sparse.sglmm(
  #   deaths ~ low_weight + black + hispanic + gini + affluence +
  #            stability + offset(log(births)),
  #   data = infant,
  #   family = poisson,
  #   A = A,
  #   method = "RSR",
  #   tune = list(sigma.s = 0.02),
  #   verbose = TRUE,
  #   minit = 4000,
  #   maxit = 8000
  # )
  # summary(fit)
  
  # iCAR: run model using INLA
  set.seed(12)
  model <- inla(
    deaths ~ low_weight + black + hispanic + gini + affluence +
             stability + f(id, model="besag", graph=A),
    data = infant,
    family = "poisson",
    E = births,
    control.compute = list(dic=TRUE),
    verbose = TRUE
  )
  print(summary(model))
  print(model$dic$deviance.mean)
  
  # TESTING: declare model using generic INLA (CAR)
  inla.rgeneric.CAR.model <- function(
    cmd = c("graph", "Q", "mu", "initial", "log.norm.const",
            "log.prior", "quit"),
    theta = NULL) {

    envir = parent.env(environment())

    interpret.theta <- function() {
      return(list(
        tau_w = exp(theta[1L]),
        rho = 1 / (1 + exp(-theta[2L]))
      ))
    }

    graph <- function(){
      require(Matrix)
      return(Diagonal(nrow(W), x = 1) + W)
    }

    Q <- function() {
      require(Matrix)
      param <- interpret.theta()
      return(param$tau_w * (Diagonal(nrow(W), x = 1) - param$rho * W) )
    }

    mu = function() { return(numeric(0)) }

    log.norm.const <- function() { return(numeric(0)) }

    log.prior <- function() {

      param = interpret.theta()
      res <- dgamma(param$tau_w, 1, 5e-05, log = TRUE) + log(param$tau_w) +
             log(1) + log(param$rho) + log(1 - param$rho)
      # res <- dgamma(param$tau_w, 2, 1, log = TRUE) + log(param$tau_w) +
      #        log(1) + log(param$rho) + log(1 - param$rho)

      return(res)

    }

    initial <- function() {
      return(c(0,0))
    }

    quit <- function() { return(invisible()) }

    res <- do.call(match.arg(cmd), args = list())

    return(res)

  }

  # TESTING: run model using generic INLA (CAR)
  set.seed(12)
  W <- as(A, "sparseMatrix")
  e.values <- eigen(W)$values
  rho.min <- min(e.values)
  rho.max <- max(e.values)
  W <- W / rho.max
  CAR.model <- inla.rgeneric.define(inla.rgeneric.CAR.model, W=W)
  model <- inla(
    deaths ~ low_weight + black + hispanic + gini + affluence +
             stability + f(id, model=CAR.model),
    data = infant,
    family = "poisson",
    E = births,
    control.compute = list(dic=TRUE)
  )
  print(summary(model))
  print(model$dic$deviance.mean)

  # # DAGAR: declare model using INLA
  # inla.rgeneric.DAGAR.model <- function(
  #   cmd = c("graph", "Q", "mu", "initial", "log.norm.const",
  #           "log.prior", "quit"),
  #   theta = NULL) {
  # 
  #   envir = parent.env(environment())
  #   
  #   interpret.theta <- function() {
  #     return(list(
  #       tau_w = exp(theta[1L]),
  #       rho = 1 / (1 + exp(-theta[2L]))
  #     ))
  #   }
  # 
  #   graph <- function(){
  #     
  #     require(Matrix)
  #     param <- interpret.theta()
  #     
  #     # Get number of neighbors
  #     dim <- length(W[1,])
  #     mtx_nbrs <- W * lower.tri(W)
  #     n_i <- as.numeric(mtx_nbrs %*% rep(1,dim))
  #     
  #     # Create matrices
  #     b_i <- param$rho / (1+((n_i-1)*(param$rho^2)))
  #     B <- mtx_nbrs * matrix(rep(b_i,dim), nrow=dim)
  #     L <- diag(rep(1,dim)) - B
  #     G <- param$tau_w * ( t(L) %*% L )
  #     
  #     return(as(G, "sparseMatrix"))
  #     
  #   }
  # 
  #   Q <- function() {
  #     
  #     require(Matrix)
  #     param <- interpret.theta()
  #     
  #     # Get number of neighbors
  #     dim <- length(W[1,])
  #     mtx_nbrs <- W * lower.tri(W)
  #     n_i <- as.numeric(mtx_nbrs %*% rep(1,dim))
  #     
  #     # Create matrices
  #     tau <- (1+(n_i-1)*(param$rho^2)) / (1-(param$rho^2))
  #     FF <- diag(tau)
  #     b_i <- param$rho / (1+((n_i-1)*(param$rho^2)))
  #     B <- mtx_nbrs * matrix(rep(b_i,dim), nrow=dim)
  #     L <- diag(rep(1,dim)) - B
  #     Q <- param$tau_w * ( t(L) %*% FF %*% L )
  #     
  #     return(as(Q, "sparseMatrix"))
  #     
  #   }
  #   
  #   mu = function() { return(numeric(0)) }
  # 
  #   log.norm.const <- function() { return(numeric(0)) }
  # 
  #   log.prior <- function() {
  # 
  #     param = interpret.theta()
  #     res <- dgamma(param$tau_w, 2, 1, log = TRUE) + log(param$tau_w) +
  #            log(1) + log(param$rho) + log(1 - param$rho)
  # 
  #     return(res)
  # 
  #   }
  # 
  #   initial <- function() {
  #     return(c(0,0))
  #   }
  # 
  #   quit <- function() { return(invisible()) }
  # 
  #   res <- do.call(match.arg(cmd), args = list())
  # 
  #   return(res)
  # 
  # }
  # 
  # # DAGAR: run model using INLA
  # set.seed(12)
  # W <- as(A, "sparseMatrix")
  # DAGAR.model <- inla.rgeneric.define(inla.rgeneric.DAGAR.model, W=W)
  # model <- inla(
  #   deaths ~ low_weight + black + hispanic + gini + affluence +
  #            stability + f(id, model=DAGAR.model),
  #   data = infant,
  #   family = "poisson",
  #   E = births,
  #   control.compute = list(dic=TRUE)
  # )
  # summary(model)
  # print(model$dic$deviance.mean)
  
}
```



# Testing: INLA
```{r}
if (FALSE) {
  
  set.seed(12)
  
  # Generate data
  data <- generate_dataset(
    type = "grid",
    tau_w = 0.25,
    phi = -1*log(0.7)
  )
  df <- data.frame(
    id = c(1:100),
    y = data$y,
    x1 = data$x1,
    x2 = data$x2
  )
  adj_mtx_grid <- generate_graph_grid() %>% adj_from_graph()
  
  # Run INLA CAR model
  model <- inla(
    y ~ x1 + x2 + f(id, model="besagproper", graph=adj_mtx_grid),
    data = df
  )
  summary(model)
  
  # Create rgeneric() ICAR model
  inla.rgeneric.CAR.model <- function(
    cmd = c("graph", "Q", "mu", "initial", "log.norm.const", "log.prior", "quit"),
    theta = NULL) {
    
    envir = parent.env(environment())
    
    interpret.theta <- function() {
      return(list(
        tau_w = exp(theta[1L]),
        rho = 1 / (1 + exp(-theta[2L]))
      ))
    }
    
    graph <- function(){
      
      # !!!!! modify
      require(Matrix)
      return(Diagonal(nrow(W), x = 1) + W)
      
    }
    
    Q <- function() {
      
      # !!!!! modify
      require(Matrix)
      param <- interpret.theta()
      return(param$tau_w * (Diagonal(nrow(W), x = 1) - param$rho * W) )
      
    }
    
    mu = function() { return(numeric(0)) }
    
    log.norm.const <- function() { return(numeric(0)) }
    
    log.prior <- function() {
      
      param = interpret.theta()
      res <- dgamma(param$tau_w, 1, 5e-05, log = TRUE) + log(param$tau_w) +
             log(1) + log(param$rho) + log(1 - param$rho)
      
      return(res)
      
    }
    
    initial <- function() {
      return(c(0,0))
    }
    
    quit <- function() { return(invisible()) }
    
    res <- do.call(match.arg(cmd), args = list())
    
    return(res)
    
  }
  W <- as(adj_mtx_grid, "sparseMatrix")  
  e.values <- eigen(W)$values
  rho.min <- min(e.values)
  rho.max <- max(e.values)
  W <- W / rho.max
  
  CAR.model <- inla.rgeneric.define(inla.rgeneric.CAR.model, W=W)

  # Run CAR model
  set.seed(12)
  model <- inla(
    y ~ x1 + x2 + f(id, model=CAR.model),
    data = df
  )
  summary(model)

}

```



# Testing
```{r}
if (FALSE) {
  
  # Adj matrix for presentation
  A <- rbind(
    c(0,1,1,0,0,0,0,0),
    c(1,0,1,1,0,0,0,0),
    c(1,1,0,1,0,0,0,1),
    c(0,1,1,0,1,0,0,1),
    c(0,0,0,1,0,1,0,1),
    c(0,0,0,0,1,0,1,1),
    c(0,0,0,0,0,1,0,1),
    c(0,0,1,1,1,1,1,0)
  )
  mtx_dagar <- generate_mtx(model="DAGAR", adj_mtx=A, rho=0.8)
  cov_dagar <- solve(mtx_dagar$Q)
  mtx_car <- generate_mtx(model="CAR", adj_mtx=A, rho=0.8)
  cov_car <- solve(mtx_car$Q)
  
  round(cov_dagar/mean(diag(cov_dagar)),2)
  round(cov_car/mean(diag(cov_car)),2)
  
}

```



# Archive
```{r}
if (FALSE) {
  
  # iCAR: Generate D matrix
  set.seed(12)
  mtx <- generate_mtx("iCAR", A)
  D <- mtx$D
  # D2 <- matrix(as.numeric(D), ncol=3071) # !!!!!
  
  # iCAR: JAGS model code
  jags_code <- quote("
    model {
      for (i in 1:k) {
        y[i] ~ dpois(
          log(births[i]) + alpha + beta1*low_weight[i] + beta2*black[i] +
          beta3*hispanic[i] + beta4*gini[i] + beta5*affluence[i] +
          beta6*stability[i] + w[i]
        )
      }
  
      w ~ dmnorm(mu0, Q)
      Q <- tau_w * ((D-A)+(0.001*I))
  
      alpha ~ dnorm(0, 0.000001)
      beta1 ~ dnorm(0, 0.000001)
      beta2 ~ dnorm(0, 0.000001)
      beta3 ~ dnorm(0, 0.000001)
      beta4 ~ dnorm(0, 0.000001)
      beta5 ~ dnorm(0, 0.000001)
      beta6 ~ dnorm(0, 0.000001)
  
      tau_w ~ dgamma(2, 1)
    }
  ")
  
  # iCAR: Generate D matrix
  # Run JAGS model
  system.time({
    jm <- jags.model(
      file = textConnection(jags_code),
      data = list(
        y = infant$deaths,
        births = infant$births,
        low_weight = infant$low_weight,
        black = infant$black,
        hispanic = infant$hispanic,
        gini = infant$gini,
        affluence = infant$affluence,
        stability = infant$stability,
        A = A,
        k = 3071,
        I = diag(rep(1,3071)),
        mu0 = rep(0,3071),
        D = D
      ),
      n.chains = 1,
      n.adapt = 10
      # n.adapt = 1000
    )
    output <- coda.samples(
      model = jm,
      variable.names = c("alpha", "beta1", "beta2", "beta3", "beta4", "beta5",
                         "beta6", "tau_w"),
      n.iter = 10,
      # n.iter = 1000,
      thin = 1
    )
    summary(output)
  })
  
}

```
